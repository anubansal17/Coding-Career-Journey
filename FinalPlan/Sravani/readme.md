# Goal - Making it to Prod Based
## Week 1 (Graphs+Recursion+Backtracking+DSU)
13 Sept - 20 Sept
### Learnings

#### 14/09/2020
1. Graph Theory (DFS, BFS, Single Source Shortest Path, All Pairs Shortest Path, Minimum Spanning Trees, Articuulation points)

#### 15/09/2020
1. Union Find Algorithm Implementation

#### 16/09/2020, 17/09/2020
1. Backtracking Theory and implementation.</br>
   a. Rat Maze problem</br>
   b. Subsets/permuatations problem</br>
   c. chessboard problem</br>
   d. n queens problem</br>
   e. sudoku problem</br>
   
### 19/09/2020
1. Backtracking graph coloring problem


## Week 2 (Greedy and Binary Search)
21 Sept - 27 Sept
### week summary:
1. Implemented Greedy Approaches :
   a. Activity Selection
   b. Huffman Encoding and decoding
   c. Job Sequencing
   d. Fractional Knapsack
   
   
## Week 3 (Buffer)
28 Sept - 4 Oct
### week summary:
1. Revised all graph concepts and implemented Below algorithms
   a. DFS, BFS for both directed and undirected
   b. Detecting a cycle both DFS, BFS and both directd and undirected
   c. Prims and Krushkals algo
   d. Dijkstras and Belman Ford
   e. Kosaraju and Tarjans Algo (Strongly connected components)
   f. Topological sorting of graphs
   
## Week 4 (Segment and Binary Indexed trees)
5 oct - 11 oct
### week summary:
1. Studied Theory about Segment Trees, when to use them

## Week 5-7 (worked on chatbot) till Oct 30
Chat is on github

## Bitmanipulation [CTCI]
1. Finding powers of 2 using bits
2. greater and lower digits with same set bits
3. Given a real number between 0 and 1 (e.g., 0.72) that is passed in as a double, print the binary representation. If the number cannot be represented accurately in binary with at most 32 characters, print "ERROR."
4. You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to insert M into N such that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all of M. That is, if M = 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j = 3 and i = 2, because M could not fully fit between bit 3 and bit 2. e.g. input: N = 10000000000, M=10011, i=2, j=6 output: N = 10001001100
5. Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on)
6. Write a function to determine the number of bits required to convert integer A to integer B. e.g. input: 31, 14 output: 2

